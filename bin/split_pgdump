#!/usr/bin/env ruby
# vim: set syntax=ruby shiftwidth=2 softtabstop=2 tabstop=8 expandtab
require 'optparse'
require 'fileutils'
require 'strscan'
require 'shellwords'

$debug = false

module SplitPgDump
  VERSION = '0.3.4'
end

class SplitPgDump::Worker
  attr_accessor :rules_file, :output_file, :sorter, :rules, :num_sorters
  attr_accessor :could_fork, :xargs
  def initialize
    @rules_file = 'split.rules'
    @output_file = 'dump.sql'
    @sorter = `which sort`.chomp
    @xargs = `which xargs`.chomp
    @rules = []
    @num_sorters = 0
    @could_fork = true
  end

  def tables_dir
    output_file + '-tables'
  end

  def clear_files
    FileUtils.rm_f output_file
    FileUtils.rm_rf Dir[File.join(tables_dir, '*')]
    FileUtils.mkdir_p tables_dir
  end

  def parse_rules
    if File.exists?(rules_file)
      File.open(rules_file) do |f|
        f.each_line do |line|
          if rule = SplitPgDump::Rule.parse(line)
            @rules << rule
          end
        end
      end
    else
      puts "NO FILE #{rules_file}"  if $debug
    end
  end

  def find_rule(table)
    @rules.find{|rule| table =~ rule.regex}
  end

  def process_schema_line(out, line)
    if line =~ /^COPY (\w+) \(([^)]+)\) FROM stdin;/
      table_name, columns = $1, $2.split(', ')
      rule = find_rule("#@schema.#{table_name}")
      @table = SplitPgDump::Table.new(tables_dir, @schema, table_name, columns, rule)
      @tables << @table
      puts "Start to write table #{table_name}" if $debug
      @start_time = Time.now
      @state = :table
    else
      if line =~ /^SET search_path = ([^,]+)/
        @schema = $1
      end
      out.write line
    end
  end

  def process_copy_line(out, line)
    if line =~ /^\\\.[\r\n]/
      @table.flush_all
      @table.copy_lines{|l| out.puts l}
      puts "Table #{@table.table} copied in #{Time.now - @start_time}s" if $debug
      @table = nil
      @state = :schema
    else
      @table.add_line(line)
    end
  end

  def work(in_stream)
    @state = :schema
    @table = nil
    @tables = []
    @schema = 'public'

    File.open(output_file, 'w') do |out|
      in_stream.each_line do |line|
        case @state
        when :schema
          process_schema_line(out, line)
        when :table
          process_copy_line(out, line)
        end
      end
    end

    @start_time = Time.now
    sort_and_finish
    puts "Finished in #{Time.now - @start_time}s #{Process.pid}" if $debug
  end

  def sort_and_finish
    files = []
    for table in @tables
      for one_file in table.files.values
        sort_args = one_file.sort_args(table.sort_args).shelljoin
        files << [one_file, sort_args]
      end
    end
    unless @xargs.empty?
      num_sorters = [@num_sorters, 1].max
      xargs_cmd = [@xargs, '-L1', '-P', num_sorters.to_s, @sorter].shelljoin
      puts xargs_cmd  if $debug
      IO.popen(xargs_cmd, 'w+') do |io|
        files.each{|one_file, sort_args|
          puts sort_args  if $debug
          io.puts sort_args
        }
        io.close_write
        io.each_line{|l| 
          puts l  if $debug
        }
      end
    else
      sorter = @sorter.shellescape
      commands = files.map{|one_file, sort_args| "#{sorter} #{sort_args}" }
      if @num_sorters > 1
        commands.each_slice(@num_sorters) do |cmd|
          cmd = cmd.map{|c| "{ #{c} & }"}  if @could_fork
          cmd = cmd.join(' ; ')
          cmd += ' ; wait '  if @could_fork
          puts cmd  if $debug
          system cmd
        end
      else
        commands.each do |cmd|
          puts cmd  if $debug
          system cmd
        end
      end
    end
    files.each{|one_file, sort_args| one_file.write_finish}
  end
end

class SplitPgDump::Rule
  class ParseError < StandardError; end

  attr_reader :regex, :split_parts, :sort_keys
  def self.parse(line)
    line = line.sub(%r{(;|#|//).*$},'').strip
    return if line.empty?

    if line =~ /^(\S+)(?:\s+split:(\S+))?(?:\s+sort:((?:(?:[^\s:]+)(?::[MbdfghinRrV]+)?(?:\s+|\s*$))+))?$/
      puts "#$1 split:#$2 sort:#$3" if $debug
      new($1, $2, $3)
    else
      raise ParseError, "Wrong rule line #{line}"
    end
  end

  def initialize(table_regex, split_expr, sort_keys)
    @regex = Regexp.new table_regex
    parse_split_expr(split_expr)
    parse_sort_keys(sort_keys)
  end

  def parse_split_expr(split_expr)
    s = StringScanner.new(split_expr || '')
    parts = []
    while !s.eos?
      if field = s.scan(/\$[^\[%!]+/)
        field = field[1..-1]
        part = {:type => :field, :field => field, :actions => []}
        while !s.eos?
          if range = s.scan(/\[[+-]?\d+\.\.\.?[+-]?\d+\]/)
            part[:actions] << {:range => range}
          elsif mod = s.scan(/%\d+/)
            part[:actions] << {:mod => mod[1..-1]}
          else
            break
          end
        end
        parts << part
        if sep = s.scan(/![^$\s#\\]*/)
          if sep > '!'
            parts << {:type => :sep, :sep => sep[1..-1]}
          end
          next
        end
      end
      raise ParseError, "Wrong format of split expr #{split_expr} (rest: '#{s.rest}')"
    end
    @split_parts = parts
  end

  def parse_sort_keys(sort_keys)
    @sort_keys = (sort_keys || '').scan(/([^\s:]+)(?::([MbdfghinRrV]+))?/).map do |key, flags|
      {:field => key, :flags => flags}
    end
  end
end

class SplitPgDump::Table
  class NoColumn < StandardError; end
  ONE_FILE_CACHE_SIZE = 256 * 1024
  TOTAL_CACHE_SIZE = 5 * 1024 * 1024

  class OneFile
    attr_reader :file_name, :cache_size
    def initialize(dir, name)
      @file_name = File.join(dir, name)
      @cache_lines = []
      @cache_size = 0
    end

    def add_line(line)
      @cache_lines << line
      @cache_size += line.size
    end

    def flush(&block)
      @cache_size = 0
      dir = File.dirname(@file_name)
      unless File.directory?(dir)
        FileUtils.mkdir_p(dir)
      end
      content = @cache_lines.join
      File.open(@file_name, 'a'){|f| f.write(content)}
      @cache_lines.clear
    end

    def write_finish
      File.open(@file_name, 'a') do |f|
        f.puts('\\.')
      end
    end

    def sort_args(sort_line = [])
      args = []
      if sort_line && !sort_line.empty?
        args.concat sort_line
      else
        args << '-n'
      end
      args.push '-o', @file_name, @file_name
      args
    end
  end

  attr_reader :table, :columns, :files, :sort_line, :sort_args
  def initialize(dir, schema, name, columns, rule)
    @dir = dir
    @table = name
    @schema = schema
    @columns = columns.map{|c| c.sub(/^"(.+)"$/, '\\1')}
    apply_rule rule
    @files = {}
    @total_cache_size = 0
  end

  def _mod(s, len, mod)
    "%0#{len}d" % (s.to_i / mod * mod)
  end

  def apply_rule(rule)
    if rule
      split_string = ''
      rule.split_parts.each do |part|
        case part[:type]
        when :sep
          split_string << part[:sep]
        when :field
          i = @columns.find_index(part[:field])
          raise NoColumn, "Table #{@schema}.#{@table} has no column #{part[:field]} for use in split"  unless i
          field = "values[#{i}]"
          part[:actions].each do |action|
            if action[:mod]
              mod_s = action[:mod]
              mod = mod_s.to_i
              field = "_mod(#{field},#{mod_s.size},#{mod})"
            elsif action[:range]
              field << "#{action[:range]}"
            end
          end
          split_string << "\#{#{field}}"
        end
      end

      eval <<-"EOF"
        def self.file_name(values)
          name = %{#{split_string}}.gsub(/\\.\\.|\\s|\\?|\\*|'|"/, '_')
          "\#{table_schema}/\#{name}.dat"
        end
      EOF

      @sort_args = rule.sort_keys.map do |key|
        i = @columns.find_index(key[:field])
        raise NoColumn, "Table #{@schema}.#{@table} has no column #{key[:field]} for use in sort"  unless i
        i += 1
        "--key=#{i},#{i}#{key[:flags]}"
      end
    else
      @sort_args = []
    end
  end

  def table_schema
    @schema == 'public' ? @table : "#@schema/#@table"
  end

  def file_name(values)
    "#{table_schema}.dat"
  end

  def add_line(line)
    values = line.chomp.split("\t")
    fname = file_name(values)
    one_file = @files[fname] ||= OneFile.new(@dir, fname)
    one_file.add_line(line)
    @total_cache_size += line.size
    if one_file.cache_size > ONE_FILE_CACHE_SIZE
      @total_cache_size -= one_file.cache_size
      one_file.flush
    end
    flush_all if @total_cache_size > TOTAL_CACHE_SIZE
  end

  def flush_all
    @files.each{|name, one_file| one_file.flush}
    @total_cache_size = 0
  end

  def copy_lines
    if block_given?
      @files.each do |name, one_file|
        yield "\\copy #{@table} (#{@columns.join(', ')}) from #{one_file.file_name}"
      end
    else
      to_enum(:copy_lines)
    end
  end
end

class SplitPgDump::ComandLineWorker < SplitPgDump::Worker
  def parse_comand_line
    opts = OptionParser.new do |opts|
      opts.version = SplitPgDump::VERSION
      opts.banner = "\
#{opts.program_name} #{opts.version}
Usage: pg_dump my_base | split_pgdump [-r RULES_FILE] [-f DUMP_FILE] [-s SORT_BIN] [-d]

split_pgdump intend for producing stable set of small files instead of one
big dump file. Such set is suitable for being source for SCM systems, being
effectivly transmitted using rsync, repacking by 7z and other.

"

      opts.separator("Options:")

      opts.on("-r", "--rules=RULES_FILE", "File with rules on table splitting (default 'split.rules')") do |v|
        self.rules_file = v
      end
      opts.on("-f", "--file=FILE", "main file name (default 'dump.sql').",
              "Table content will be storred in FILE-tables directory") do |v|
        self.output_file = v
      end
      opts.on("-s", "--sort=SORT_BIN", "sort executable compatible with gnu coreutils sort (default `which sort`)") do |v|
        self.sorter = v
      end
      opts.on("-n", "--sorters=NUM", Integer, "number of sorters started in a shell") do |n|
        self.num_sorters = n.to_i
      end
      opts.on("--no-shell-fork", "could not use shell & for parrallel execution of sorters") do 
        self.could_fork = false
      end
      opts.on("-x", "--xargs=XARGS_BIN", "xargs executable (-L and -P options used) (default `which xargs`)") do |v|
        self.xargs = v
      end
      opts.on("--no-xargs", 'explicitly disable xargs') do
        self.xargs = ''
      end
      opts.on("-d", "--debug", "debug"){|v| $debug = true}
      opts.on_tail("-v", "--version", "show version") do
        puts opts.version
        exit
      end
      opts.on_tail("-h", "--help", "this message"){|v| puts opts; exit}

      opts.on_tail("\
Rules file format:
table_regexp  {split:<Split expr>} {sort:<Sort expr>}

<Split expr> examples:
  split:$field_name!
  split:$field_name!_$other_field!
  split:$client_id%00100!-$id%0025000!
  split:$some_field[2..-1]!/$other_field[10..30]%0005!

<Sort expr> is space separated list of fields, optionally with options for
gnu `sort` --key parameters (on my machine they are MbdfghinRrV):
  sort:client_id uid
  sort:client_id:n id:n

Example for redmines wiki_content_versions:

wiki_content_versions split:$page_id%0025!/$id%0000250! sort:page_id:n id:n
    ")

    end.parse!
  end
end

if $0 == __FILE__
  worker = SplitPgDump::ComandLineWorker.new
  worker.parse_comand_line
  worker.parse_rules
  worker.clear_files
  worker.work(STDIN)
end
